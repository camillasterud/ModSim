\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[norsk]{babel}
\usepackage{lmodern}
\usepackage{float}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps,.pdf,.png,.jpg}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage[euler]{textgreek}
\usepackage{stackengine}
\usepackage{listings}
\usepackage[version-1-compatibility]{siunitx}
\usepackage{pdfpages}
\usepackage{fixltx2e}
\hypersetup{pdfborder={0 0 0}}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\pgfplotsset{plot coordinates/math parser=false}
\newlength\figureheight
\newlength\figurewidth
\usepackage[section]{placeins}%SÃ¸rger for at plots og andre floats holder seg til sin section.
\setlength\parindent{0pt}%Setter indent til 0



\title{Exercise 3 - TTK4130 Modeling and Simulation}
\author{Camilla Sterud}
\date{}

\begin{document}

\maketitle

\newpage

\section{Problem 1}

\begin{align}
	k_1 &= f(y_n,t_n)\label{eq:k1}\\
	k_2 &= f(y_n + ha_{21}k_1,t_n + hc_2)\label{eq:k2}\\
	y_{n+1} &= y_n + h(b_1k_1 + b_2k_2)\label{eq:ynext}
\end{align}

Taylor expansion of a funciton of two variables:

\begin{equation}\label{eq:taylorexp}
	f(y + \Delta, t + \delta) = f(y,t) + \Delta\frac{\partial f(y,t)}{\partial y} + \delta\frac{\partial f(y,t)}{\partial t} + O(\Delta^2) + O(\delta\Delta) + O(\delta^2)
\end{equation}


\subsection{a}



\begin{equation*}
	\frac{df(y_n,t_n)}{dt}) = \frac{\partial f(y_n,t_n)}{\partial y}\frac{dy}{dt} + \frac{\partial f(y_n,t_n)}{\partial t} = \frac{\partial f(y_n,t_n)}{\partial y}f(y_n,t_n)+ \frac{\partial f(y_n,t_n)}{\partial t}.
\end{equation*}

$a_{21} = c_1 = C$. Taylor expansion of Equation \ref{eq:k2} using Equation \ref{eq:taylorexp}:

\begin{align*}
	k_2 &= f(y_n,t_n) + ha_{21}k_1\frac{\partial f(y,t)}{\partial y} + hc_2\frac{\partial f(y,t)}{\partial t} + O((ha_{21}k_1)^2) + O(h^2c_2a_{21}k_1) + O(h^2c_2^2)\\
	&= k_1 + hC(k_1\frac{\partial f(y,t)}{\partial y} + \frac{\partial f(y,t)}{\partial t}) + O(h^2C^2)
\end{align*}

\begin{equation}\label{eq:k2exp}
	\underline{\underline{k_2 = f(y_n,t_n) + hC\frac{df(y_n,t_n)}{dt} + O(h^2)}}
\end{equation}

\subsection{b}

From p. 518, Egeland \& Gravdal:
A method is of order $p$ if $p$ is the smallest number that satifies

\begin{equation}\label{eq:order}
	y_{n+1} = y_n + hf(y_n,t_n) + ... + \frac{h^p}{p!} \frac{d^{p-1}f(y_n,t_n)}{dt^{p-1}} + O(h^{p+1}).
\end{equation}

Putting the taylor expansion of $k_2$ from Equation \ref{eq:k2exp} and Equation \ref{eq:k1} into Equation \ref{eq:ynext} yields

\begin{align*}
	y_{n+1} &= y_n + hb_1f(y_n,t_n) + hb_2(f(y_n,t_n) + hC\frac{df(y_n,t_n)}{dt} + O(h^2))\\
	y_{n+1} &= y_n + h(b_1+b_2)f(y_n,t_n) + h^2b_2C\frac{df(y_n,t_n)}{dt} + O(h^3) \\
	\Rightarrow b_1+b_2 &= 1 \quad b_2C = \frac{1}{2!}
\end{align*}

\begin{equation*}
	\underline{\underline{c_2 = a_{12} = \frac{1}{2b_2}, \quad b_1 = 1-b_2}}
\end{equation*}


\section{Problem 2}

\subsection{a}

\begin{figure}[!ht]\label{fig:spring2a}
	\centering
	\includegraphics[width = 0.5\textwidth]{ModSim_ex4_2a}
    \caption{The pneumatic spring simulated with the explicit Euler method. The code for generating this plot is shown in Listing \ref{code2a}.}
\end{figure}

As seen in Figure \ref{fig:spring2a}, the explicit Euler method is on the verge of stability for this system. The position of the spring should be decreasing, but insted it oscillates around $\simeq 1.2$.

\subsection{b}

\begin{figure}[!ht]\label{fig:spring2b}
	\centering
	\includegraphics[width = 0.5\textwidth]{ModSim_ex4_2b}
    \caption{The pneumatic spring simulated with the implicit Euler method. The code for generating this plot is shown in Listing \ref{code2b}.}
\end{figure}

\subsection{c}

\begin{figure}[!ht]\label{fig:spring2c}
	\centering
	\includegraphics[width = 0.5\textwidth]{ModSim_ex4_2c}
    \caption{The pneumatic spring simulated with the implicit midpoint rule. The code for generating this plot is shown in Listing \ref{code2c}.}
\end{figure}

\subsection{d}

\begin{figure}[!ht]\label{fig:spring2d}
	\centering
	\includegraphics[width = 0.5\textwidth]{ModSim_ex4_2d}
    \caption{The energy in the system for the three solvers. The code for generating this plot is shown in Listing \ref{code2d}.}
\end{figure}

\section{Problem 3}

Voltage controlled DC motor:

\begin{align*}
	L_1\frac{di_a}{dt} &= - R_ai_a - K_E\omega_m + u_a\\
	J_m\frac{d\omega_m}{dt} &= K_Ti_a - T_L\\
	K_E &= K_T.
\end{align*}

\subsection{a}

$T_L = u_a = 0$. Energy function for the system:

\begin{equation*}
	E = \frac{1}{2}L_ai_a^2 + \frac{1}{2}J_m\omega_m^2.
\end{equation*}

To prove stability, the energy in the system must be decreasing for all times. 

\begin{align*}
	\dot E &= L_ai_a\frac{di_a}{dt} + J_m\omega_m\frac{d\omega_m}{dt}\\
	&= -R_ai_a^2 - K\omega_mi_a + i_au_a+K\omega_mi_a - \omega_mT_L
	
\end{align*}

\begin{equation*}
	\underline{\underline{\dot E = -R_ai_a^2 \leq 0 \:\forall\: t > 0 \: \Rightarrow \text{The system is stable}}}
\end{equation*}

\subsection{b}
To prove passivity, the storage function, $V$, must fulfill the criteria $\dot V = \mathbf{u}^T\mathbf{y} - g(x), g(x) \geq 0$. $\mathbf{u} = \begin{bmatrix} u_a & -T_L\end{bmatrix}, \mathbf{y} = \begin{bmatrix} i_a & \omega_m\end{bmatrix}$.

\begin{align*}
	V &= E\\
	\dot V &= -R_ai_a^2 - K\omega_mi_a + i_au_a+K\omega_mi_a - \omega_mT_L\\
	&= -R_ai_a^2 + i_au_a - \omega_mT_L
	
\end{align*}

\begin{equation*}
	\underline{\underline{\dot V =\mathbf{u}^T\,\mathbf{y} - R_ai_a^2, \: g(x) = R_ai_a^2 \geq 0 \Rightarrow \text{The system is passive.}}}
\end{equation*}

\section{c}


\section{Listings}


\begin{lstlisting}[language=Matlab, frame = single, caption = The explicit Euler method implemented i MATLAB,, label=code2a]
hold on; grid on;

kappa = 1.4;
g = 9.81;

h = 0.01;
t = 0:h:10;

ya = zeros (2,length(t));
ya(1,1) = 2;
ya(2,1) = 0;

f = @(ya) [ya(2);g*(ya(1)^(-kappa) - 1)];

for i = 1:(length(t) - 1)
    
    k_1 = f(ya(:,i));
    k_2 = f(ya(:,i) + 0.5*h.*k_1);
    
    ya(:,i+1) = ya(:,i) + h.*k_2;
    
end

plot(t,ya(1,:));
xlabel('t(s)');
ylabel('x(m)');

print -depsc modsim_ex4_2a.eps
\end{lstlisting}

\begin{lstlisting}[language=Matlab, frame = single, caption = The implicit Euler method implemented i MATLAB,, label=code2b]

hold on; grid on;

kappa = 1.4;
g = 9.81;

h = 0.01;
t = 0:h:10;

yb = zeros (2,length(t));
yb(1,1) = 2;
yb(2,1) = 0;

f = @(yb) [yb(2);g*(yb(1)^(-kappa) - 1)];

opt = optimset('Display','off','TolFun',1e-8);

for i = 1:(length(t) - 1)
    
    r = @(ybnext) (yb(:,i) + h*feval(f, ybnext) - ybnext);
    yb(:,i+1) = fsolve(r, yb(:,i), opt);
    
end

plot(t,yb(1,:));
xlabel('t(s)');
ylabel('x(m)');

print -depsc modsim_ex4_2b.eps
\end{lstlisting}

\begin{lstlisting}[language=Matlab, frame = single, caption = The implicit midpoint rule implemented i MATLAB,, label=code2c]

hold on; grid on;

kappa = 1.4;
g = 9.81;

h = 0.01;
t = 0:h:10;

yc = zeros (2,length(t));
yc(1,1) = 2;
yc(2,1) = 0;

f = @(yc) [yc(2);g*(yc(1)^(-kappa) - 1)];

opt = optimset('Display','off','TolFun',1e-8);

for i = 1:(length(t) - 1)
    
    r = @(ycnext) (yc(:,i) + h/2*feval(f, ycnext) - ycnext);
    yc(:,i+1) = fsolve(r, yc(:,i), opt);
    
end

plot(t,yc(1,:));
xlabel('t(s)');
ylabel('x(m)');

print -depsc modsim_ex4_2c.eps
\end{lstlisting}

\begin{lstlisting}[language=Matlab, frame = single, caption = The implicit midpoint rule implemented i MATLAB,, label=code2d]

hold on; grid on;

h = 0.01;
t = 0:h:10;

p0 = 2.5*10^5;
m = 200;
A = 0.01;

Ea = (1/(kappa-1))*p0*A.*ya(1,:).^(1-kappa) + m*g.*ya(1,:) + 0.5*m.*ya(2,:).^2;
Eb = (1/(kappa-1))*p0*A.*yb(1,:).^(1-kappa) + m*g.*yb(1,:) + 0.5*m.*yb(2,:).^2;
Ec = (1/(kappa-1))*p0*A.*yc(1,:).^(1-kappa) + m*g.*yc(1,:) + 0.5*m.*yc(2,:).^2;


plot(t,Ea);
plot(t,Eb);
plot(t,Ec);
xlabel('t(s)');
ylabel('E(J)');
legend('Explicit Euler','Implicit Euler','Implicit midpoint');

print -depsc modsim_ex4_2d.eps
\end{lstlisting}

\end{document}